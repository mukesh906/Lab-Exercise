Free wheeling loops in threads puts a considerable load on the CPU which can have an adverse affect on other threads. Remember, more threads doesn't always mean more work gets done faster.

What's needed is some way to "yield" time, so the CPU can better schedule other threads.

Since you're only interested in a second accuracy, using a sleep of half a second is a good place to start. This greatly reduces the amount of time that each threads needs on the CPU.

Personally, when dealing with time based solutions like this, I prefer to use the date/time API, as it generally produces a better and more reliable solution, but that's me.

The following example simply starts 10 threads, each with a 5 second timeout. Each thread sleeps for half a second before running through it's prescribed logic

import java.time.Duration;
import java.time.Instant;
import java.util.Random;

public class Test {

    public static void main(String[] args) throws InterruptedException {
        new Test();
    }

    public Test() throws InterruptedException {
        Random rnd = new Random();
        for (int index = 0; index < 10; index++) {
            Thread t = new Thread(new Timeout(5, "Cookie " + index));
            t.start();
        }

        Thread.sleep(500);
    }

    public class Timeout implements Runnable {

        private Duration duration;
        private Instant startTime;
        private String label;

        public Timeout(int count, String label) {
            duration = Duration.ofSeconds(count);
            this.label = label;
        }

        @Override
        public void run() {
            long time = Long.MAX_VALUE;
            try {
                startTime = Instant.now();
                while (true) {
                    Duration runTime = Duration.between(startTime, Instant.now());
                    Duration remainingTime = duration.minus(runTime);
                    // You could also use remainingTime.getSeconds() == 0, but it
                    // depends on your desired level of accuracy
                    if (remainingTime.isNegative()) {
                        System.out.println("Out of time");
                        return;
                    } else {
                        if (time != remainingTime.getSeconds()) {
                            time = remainingTime.getSeconds();
                            System.out.println(label + " " + duration.getSeconds() + "/" + time);
                        }
                    }
                    Thread.sleep(500);
                }
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }
}
